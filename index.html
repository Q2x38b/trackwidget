<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
<title>Hand Tracker Canvas — Client-Side</title>
<style>
  :root {
    --bg: #0f1115;
    --panel: #151821;
    --text: #e8eaf0;
    --muted: #8b93a7;
    --accent: #5ac8fa;
    --ok: #34c759;
    --warn: #ff9f0a;
  }
  * { box-sizing: border-box; }
  html, body { height: 100%; min-height: 100dvh; margin: 0; background: radial-gradient(1200px 800px at 80% -10%, #121521, #0d0f14 45%, #0a0c10 100%); color: var(--text); font: 14px/1.35 system-ui, -apple-system, Segoe UI, Roboto, Inter, "Helvetica Neue", Arial, sans-serif; }
  .app {
    display: grid; grid-template-rows: auto 1fr auto; gap: 10px; height: 100dvh; padding: 14px; max-width: 100vw; margin: 0 auto;
  }
  header {
    display: flex; gap: 12px; align-items: center; justify-content: space-between;
    background: linear-gradient(180deg, #171a23 0%, #121520 100%); border: 1px solid #22283a; border-radius: 14px; padding: 10px 12px;
    box-shadow: 0 1px 0 rgba(255,255,255,0.04) inset, 0 14px 40px rgba(0,0,0,0.35);
  }
  header .left { display: flex; gap: 10px; align-items: center; }
  .badge {
    border: 1px solid #283047; background: #121728; padding: 6px 10px; border-radius: 999px; color: var(--muted);
  }
  .controls { display: flex; flex-wrap: wrap; gap: 8px; align-items: center; }
  .btn, .toggle {
    appearance: none; border: 1px solid #2a3147; background: #141828; color: var(--text);
    padding: 8px 10px; border-radius: 10px; cursor: pointer; transition: 120ms transform ease, 120ms background ease, 120ms border-color ease;
  }
  .btn:hover, .toggle:hover { transform: translateY(-1px); border-color: #39425e; }
  .btn:active, .toggle:active { transform: translateY(0); }
  .toggle[data-on="true"] { background: #0f1b2e; border-color: #3d6ea3; box-shadow: 0 0 0 1px #284a72 inset; }
  .small { font-size: 12px; color: var(--muted); }
  .stage {
    position: relative; border-radius: 16px; overflow: hidden; background: #0b0e15; border: 1px solid #1b2133;
    box-shadow: 0 0 0 1px rgba(255,255,255,0.02) inset, 0 24px 70px rgba(0,0,0,0.45);
    min-height: 320px;
    height: 100%;
    transition: box-shadow 160ms ease, border-color 160ms ease;
  }
  /* Stage glow states */
  .stage.hand-detected {
    box-shadow: 0 0 0 1px rgba(255,255,255,0.02) inset,
                0 24px 70px rgba(0,0,0,0.45),
                0 0 16px 2px rgba(90,200,250,0.25);
    border-color: #28486e;
  }
  /* Removed pinch/engaged glow — border glows only on detection */
  .layer { position: absolute; inset: 0; }
  video { width: 100%; height: 100%; object-fit: cover; filter: saturate(0.95) contrast(1.05) brightness(0.95); transform: scaleX(-1); } /* mirrored for natural UX */
  canvas { width: 100%; height: 100%; display: block; touch-action: none; }
  .overlay {
    pointer-events: none;
  }
  /* Sliders */
  input[type="range"] {
    appearance: none;
    height: 4px;
    background: #1b2133;
    border-radius: 999px;
    outline: none;
    border: 1px solid #2a3147;
  }
  input[type="range"]::-webkit-slider-thumb {
    appearance: none;
    width: 14px; height: 14px; border-radius: 50%;
    background: var(--accent);
    border: 1px solid #2a3147;
    box-shadow: 0 1px 0 rgba(255,255,255,0.05) inset;
  }
  input[type="color"] { height: 28px; width: 36px; border-radius: 6px; border: 1px solid #2a3147; background: #111526; }
  footer {
    display: flex; align-items: center; justify-content: space-between; gap: 10px;
    color: var(--muted);
  }
  .legend { display: flex; gap: 14px; flex-wrap: wrap; }
  .dot { width: 10px; height: 10px; border-radius: 50%; display: inline-block; margin-right: 6px; vertical-align: -1px; }
  .dot.accent { background: var(--accent); }
  .dot.ok { background: var(--ok); }
  .dot.warn { background: var(--warn); }
  .status { color: var(--muted); }
  .err { color: #ff453a; }
  .hidden { display: none !important; }

  /* Widget styling hints for hover/tap */
  .hint {
    position: absolute; top: 12px; right: 12px; background: rgba(0,0,0,0.45); border: 1px solid #2a3147;
    padding: 6px 10px; border-radius: 999px; font-size: 12px; color: #cdd3e2;
    backdrop-filter: blur(8px);
  }
</style>
</head>
<body>
<div class="app">
  <header>
    <div class="left">
      <span class="badge">Hand Tracker</span>
      <div class="small">Pinch thumb + index to interact. Enable Draw Mode to sketch; release to stop.</div>
    </div>
    <div class="controls">
      <button id="btnStart" class="btn">Enable Camera</button>
      <button id="btnReset" class="btn">Reset Widgets</button>
      <button id="btnSpawn" class="btn">Add Widget</button>
      <button id="btnClear" class="btn">Clear Widgets</button>
      <button id="togglePointer" class="toggle" data-on="true" aria-pressed="true">Show Pointer</button>
      <span class="small" style="margin-left:8px;">| Drawing</span>
      <button id="btnDrawMode" class="toggle" data-on="false" aria-pressed="false">Draw Mode</button>
      <button id="btnEraser" class="toggle" data-on="false" aria-pressed="false" disabled>Eraser</button>
      <input id="colorPicker" type="color" value="#ff375f" title="Brush color" />
      <input id="brushSize" type="range" min="2" max="36" value="8" title="Brush size" />
      <button id="btnClearSketch" class="btn">Clear Drawing</button>
      <button id="btnSave" class="btn">Save PNG</button>

      <span class="small" style="margin-left:8px;">| Smooth</span>
      <label class="small" title="Smoothing cutoff (lower = smoother)">
        cutoff
        <input id="smoothingCutoff" type="range" min="0.8" max="4" step="0.1" value="1.7" />
      </label>
      <label class="small" title="Smoothing beta (higher = more responsive)">
        beta
        <input id="smoothingBeta" type="range" min="0" max="1.5" step="0.05" value="0.6" />
      </label>
      <span class="small" style="margin-left:8px;">| Pointer</span>
      <label class="small" title="Pointer size">
        size
        <input id="pointerSize" type="range" min="4" max="20" step="1" value="7" />
      </label>
    </div>
  </header>

  <div class="stage" id="stage">
    <div class="hint">👆 Pinch to grab</div>
    <video id="video" class="layer hidden" playsinline muted></video>
    <canvas id="sketch" class="layer"></canvas>
    <canvas id="canvas" class="layer"></canvas>
    <canvas id="overlay" class="layer overlay"></canvas>
  </div>

  <footer>
    <div class="legend">
      <span><span class="dot ok"></span>Pointer</span>
      <span>Pinch to draw (when Draw Mode is on)</span>
    </div>
    <div class="status" id="status">Idle.</div>
  </footer>
</div>

<!-- Hand tracking with MediaPipe Tasks Vision (WASM, fully client-side) -->
<script type="module">
/**
 * Fully client-side hand tracker using MediaPipe Tasks Vision (WASM).
 * - Detects hand landmarks from your webcam.
 * - Uses index fingertip (landmark 8) as a pointer.
 * - Uses thumb tip (4) + index tip (8) distance to detect pinch (grab).
 * - Lets you drag "widgets" (shapes) around a canvas with a pinch gesture.
 *
 * Notes:
 * - All processing happens locally in your browser.
 * - Mirrored video for natural left/right motion.
 */

const statusEl = document.getElementById('status');
const video = document.getElementById('video');
const sketch = document.getElementById('sketch');     // persistent drawing layer
const canvas = document.getElementById('canvas');     // interaction layer (widgets)
const overlay = document.getElementById('overlay');   // pointer & debug
const btnStart = document.getElementById('btnStart');
const btnReset = document.getElementById('btnReset');
const btnSpawn = document.getElementById('btnSpawn');
const btnClear = document.getElementById('btnClear');
const togglePointer = document.getElementById('togglePointer');
const btnDrawMode = document.getElementById('btnDrawMode');
const btnEraser = document.getElementById('btnEraser');
const colorPicker = document.getElementById('colorPicker');
const brushSizeInput = document.getElementById('brushSize');
const btnClearSketch = document.getElementById('btnClearSketch');
const btnSave = document.getElementById('btnSave');
const smoothingCutoffInput = document.getElementById('smoothingCutoff');
const smoothingBetaInput = document.getElementById('smoothingBeta');
const pointerSizeInput = document.getElementById('pointerSize');
const stage = document.getElementById('stage');

let showPointer = true;
let handLandmarker = null;
let cameraStream = null;
let running = false;
let lastVideoTime = -1;

// Pointer + landmark smoothing (One Euro filter)
let pointer = { x: 0, y: 0, valid: false };
let lmFilters = null; // [{fx: OneEuro1D, fy: OneEuro1D}] length = 21 for first hand
let lastFilterTime = null;
const ONE_EURO_CFG = { minCutoff: 1.7, beta: 0.6, dCutoff: 1.0 };
// Pointer velocity for inertial widget throws
let prevPointerX = null, prevPointerY = null;
let pointerVelX = 0, pointerVelY = 0; // px/sec
// De-emphasize legacy linear smoothing
// const SMOOTHING = 0.35; // deprecated by One Euro

// Pinch detection state
let isPinching = false;
let pinchStrength = 0; // 0..1
// Pinch hysteresis thresholds (slightly easier to grab)
const PINCH_ON = 0.55;
const PINCH_OFF = 0.38;

// Widgets state
/**
 * @typedef {'square'|'circle'|'note'} WidgetKind
 * @typedef {{id:number, x:number, y:number, w:number, h:number, kind:WidgetKind, vx?:number, vy?:number, text?:string}} Widget
 */
/** @type {Array<Widget>} */
let widgets = [];
let grabbedId = null;
let nextId = 1;

// Drawing state
let drawMode = false;
let eraseMode = false;
let isDrawing = false;
let lastDrawX = 0, lastDrawY = 0;
let brushColor = '#ff375f';
let brushSize = 8; // CSS px (will be scaled by devicePixelRatio)
const sketchCtx = () => sketch.getContext('2d');
let lastDoubleClick = 0;

// Pointer visuals and smoothing controls
let pointerRadius = 7; // CSS px

// Fit canvases to stage size
function resizeCanvases() {
  const rect = stage.getBoundingClientRect();
  for (const el of [sketch, canvas, overlay]) {
    el.width = Math.floor(rect.width * devicePixelRatio);
    el.height = Math.floor(rect.height * devicePixelRatio);
    el.style.width = rect.width + 'px';
    el.style.height = rect.height + 'px';
  }
}

// Utility: lerp
const lerp = (a, b, t) => a + (b - a) * t;

// Utility: clamp
const clamp = (v, a, b) => Math.max(a, Math.min(b, v));

// Promise timeout helper
function withTimeout(promise, ms, label) {
  return new Promise((resolve, reject) => {
    const t = setTimeout(() => reject(new Error(`${label} timed out after ${Math.round(ms/1000)}s`)), ms);
    promise.then(
      (v) => { clearTimeout(t); resolve(v); },
      (err) => { clearTimeout(t); reject(err); }
    );
  });
}

// Map normalized landmark (0..1) to overlay pixel coords (already devicePixelRatio scaled)
function normToPx(nx, ny) {
  // Video is mirrored (scaleX(-1)), so flip X for more intuitive pointer
  const px = (1 - nx) * overlay.width;
  const py = ny * overlay.height;
  return [px, py];
}

// One Euro filter implementation for smoother, responsive tracking
class LowPassFilter {
  constructor(alpha = 1.0) {
    this.alpha = alpha;
    this.initialized = false;
    this.s = 0;
  }
  filter(value, alpha = this.alpha) {
    if (!this.initialized) {
      this.initialized = true;
      this.s = value;
      return value;
    }
    this.s = this.s + alpha * (value - this.s);
    return this.s;
  }
  lastValue() { return this.s; }
}

function alphaFor(dt, cutoff) {
  const tau = 1.0 / (2 * Math.PI * cutoff);
  return 1.0 / (1.0 + tau / dt);
}

class OneEuro1D {
  constructor({ minCutoff = 1.7, beta = 0.6, dCutoff = 1.0 } = {}) {
    this.minCutoff = minCutoff;
    this.beta = beta;
    this.dCutoff = dCutoff;
    this.dxFilter = new LowPassFilter();
    this.xFilter = new LowPassFilter();
    this.prevX = null;
  }
  filter(x, dt) {
    const dx = this.prevX == null ? 0 : (x - this.prevX) / dt;
    const edx = this.dxFilter.filter(dx, alphaFor(dt, this.dCutoff));
    const cutoff = this.minCutoff + this.beta * Math.abs(edx);
    const result = this.xFilter.filter(x, alphaFor(dt, cutoff));
    this.prevX = result;
    return result;
  }
}

function ensureLmFilters(count) {
  if (lmFilters && lmFilters.length === count) return;
  lmFilters = Array.from({ length: count }, () => ({
    fx: new OneEuro1D(ONE_EURO_CFG),
    fy: new OneEuro1D(ONE_EURO_CFG)
  }));
}

// Widget helpers
function spawnWidget(kind, x, y) {
  const baseSize = Math.max(60, Math.min(overlay.width, overlay.height) * 0.08);
  if (kind === 'circle') {
    widgets.push({ id: nextId++, x, y, w: baseSize, h: baseSize, kind, vx: 0, vy: 0 });
  } else if (kind === 'note') {
    widgets.push({ id: nextId++, x, y, w: baseSize * 1.6, h: baseSize * 1.1, kind, vx: 0, vy: 0, text: 'Note' });
  } else {
    widgets.push({ id: nextId++, x, y, w: baseSize, h: baseSize, kind: 'square', vx: 0, vy: 0 });
  }
}

function resetWidgets() {
  widgets = [];
  const cx = overlay.width * 0.33, cy = overlay.height * 0.55;
  spawnWidget('square', cx - 90, cy);
  spawnWidget('circle', cx + 90, cy - 30);
  spawnWidget('note', cx + 20, cy + 90);
}

function clearWidgets() {
  widgets = [];
}

const HIT_EXPAND = 24 * devicePixelRatio; // larger hit targets for easier grabs
let grabOffsetX = 0, grabOffsetY = 0;    // preserve offset when grabbing

function pickWidget(px, py) {
  // topmost first — iterate from end
  for (let i = widgets.length - 1; i >= 0; i--) {
    const w = widgets[i];
    if (w.kind === 'circle') {
      const dx = px - w.x, dy = py - w.y;
      if (Math.hypot(dx, dy) <= w.w * 0.5 + HIT_EXPAND) return w.id;
    } else {
      // square or note are rectangles
      if (
        px >= w.x - w.w/2 - HIT_EXPAND &&
        px <= w.x + w.w/2 + HIT_EXPAND &&
        py >= w.y - w.h/2 - HIT_EXPAND &&
        py <= w.y + w.h/2 + HIT_EXPAND
      ) {
        return w.id;
      }
    }
  }
  return null;
}

function moveWidget(id, px, py) {
  const w = widgets.find(v => v.id === id);
  if (!w) return;
  w.x = clamp(px, w.w/2, overlay.width - w.w/2);
  w.y = clamp(py, w.h/2, overlay.height - w.h/2);
}

// Physics disabled: widgets stay where released
function updateWidgetPhysics(dtSec) {
  // Intentionally no-op to remove inertia/gravity
}

function drawWidgets(ctx) {
  ctx.save();
  ctx.scale(1, 1);
  for (const w of widgets) {
    ctx.save();
    ctx.translate(w.x, w.y);
    // cards glow
    ctx.shadowColor = 'rgba(0,0,0,0.5)';
    ctx.shadowBlur = 18 * devicePixelRatio;
    ctx.lineWidth = 2 * devicePixelRatio;

    if (w.kind === 'circle') {
      const r = w.w * 0.5;
      const g = (grabbedId === w.id) ? 'rgba(90,200,250,0.9)' : 'rgba(90,200,250,0.35)';
      ctx.beginPath();
      ctx.arc(0, 0, r, 0, Math.PI * 2);
      ctx.fillStyle = 'rgba(20,24,40,0.9)';
      ctx.strokeStyle = g;
      ctx.fill();
      ctx.stroke();
    } else {
      const radius = 14 * devicePixelRatio;
      const ww = w.w, hh = w.h;
      roundRectPath(ctx, -ww/2, -hh/2, ww, hh, radius);
      ctx.fillStyle = 'rgba(20,24,40,0.9)';
      ctx.fill();
      ctx.strokeStyle = (grabbedId === w.id) ? 'rgba(90,200,250,0.9)' : 'rgba(90,200,250,0.35)';
      ctx.stroke();

      // A little header bar for notes
      if (w.kind === 'note') {
        ctx.save();
        ctx.beginPath();
        roundRectPath(ctx, -ww/2, -hh/2, ww, 18 * devicePixelRatio, radius);
        ctx.fillStyle = 'rgba(90,200,250,0.15)';
        ctx.fill();
        ctx.restore();
        // Note text
        drawWidgetText(ctx, w.text || 'Note', ww, hh, { topPadding: 26 * devicePixelRatio });
      }
    }
    ctx.restore();
  }
  ctx.restore();
}

function roundRectPath(ctx, x, y, w, h, r) {
  const rr = Math.min(r, w/2, h/2);
  ctx.beginPath();
  ctx.moveTo(x + rr, y);
  ctx.arcTo(x + w, y, x + w, y + h, rr);
  ctx.arcTo(x + w, y + h, x, y + h, rr);
  ctx.arcTo(x, y + h, x, y, rr);
  ctx.arcTo(x, y, x + w, y, rr);
  ctx.closePath();
}

function drawWidgetText(ctx, text, w, h, opts = {}) {
  const pad = 10 * devicePixelRatio;
  const maxWidth = w - pad * 2;
  const fontPx = Math.max(12 * devicePixelRatio, Math.min(20 * devicePixelRatio, h * 0.28));
  ctx.fillStyle = '#d7deee';
  ctx.font = `${fontPx}px/1.2 system-ui, -apple-system, Segoe UI, Inter, Roboto`;
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  let tx = 0;
  let ty = 0;
  if (opts.center) {
    ty = 0;
  } else {
    ty = -h/2 + pad + fontPx * 0.5 + (opts.topPadding || 0);
  }
  // Simple truncation if too long
  let t = String(text);
  while (ctx.measureText(t).width > maxWidth && t.length > 3) {
    t = t.slice(0, -2) + '…';
  }
  ctx.fillText(t, tx, ty);
}

// Clock widget removed

// Draw overlay (landmarks, pointer, pinch)
function drawOverlay(results) {
  const ctx = overlay.getContext('2d');
  ctx.clearRect(0, 0, overlay.width, overlay.height);

  // pointer
  if (pointer.valid && showPointer) {
    ctx.save();
    const r = pointerRadius * devicePixelRatio;
    // glow ring if grabbing or hovering over a widget
    const hoveringId = pickWidget(pointer.x, pointer.y);
    const engaging = isPinching || grabbedId != null || hoveringId != null;
    if (engaging) {
      ctx.shadowColor = 'rgba(52,199,89,0.65)';
      ctx.shadowBlur = 14 * devicePixelRatio;
    }
    ctx.beginPath();
    ctx.arc(pointer.x, pointer.y, r, 0, Math.PI * 2);
    ctx.fillStyle = '#34c759';
    ctx.fill();
    // subtle ring
    ctx.beginPath();
    ctx.arc(pointer.x, pointer.y, r + 5 * devicePixelRatio, 0, Math.PI * 2);
    ctx.strokeStyle = engaging ? 'rgba(52,199,89,0.5)' : 'rgba(255,255,255,0.18)';
    ctx.lineWidth = 2 * devicePixelRatio;
    ctx.stroke();
    ctx.restore();
  }
}

// Run loop — always render widgets; run inference only when ready
let lastFrameTime = null;
async function frame() {
  const now = performance.now();
  const dtFrameSec = lastFrameTime == null ? 1/60 : clamp((now - lastFrameTime) / 1000, 1/240, 0.1);
  lastFrameTime = now;

  let results = null;
  const canDetect = running && handLandmarker && video.readyState >= 2;

  if (canDetect && video.currentTime !== lastVideoTime) {
    lastVideoTime = video.currentTime;
    results = handLandmarker.detectForVideo(video, now);

    // Extract landmarks of first hand and smooth
    let tip8 = null, tip4 = null;
    if (results?.landmarks?.length) {
      const lms = results.landmarks[0];
      ensureLmFilters(lms.length);

      // dt in seconds for One Euro filter
      let dt = 1 / 60;
      if (lastFilterTime != null) {
        dt = (now - lastFilterTime) / 1000;
        dt = clamp(dt, 1 / 240, 0.1);
      }
      lastFilterTime = now;

      // Smooth landmarks in normalized space
      const smoothed = lms.map((p, i) => ({
        x: lmFilters[i].fx.filter(p.x, dt),
        y: lmFilters[i].fy.filter(p.y, dt),
      }));

      tip8 = smoothed[8];
      tip4 = smoothed[4];
      // Direct pixel mapping from smoothed fingertip for accuracy
      const [px, py] = normToPx(tip8.x, tip8.y);
      pointer.x = clamp(px, 0, overlay.width);
      pointer.y = clamp(py, 0, overlay.height);
      pointer.valid = true;
      // stage glow: detected when we have landmarks; engaged when pinching or grabbing
      stage.classList.add('hand-detected');
      // Pointer velocity (px/sec)
      if (prevPointerX != null && prevPointerY != null) {
        pointerVelX = (pointer.x - prevPointerX) / dt;
        pointerVelY = (pointer.y - prevPointerY) / dt;
      }
      prevPointerX = pointer.x;
      prevPointerY = pointer.y;

      // Pinch metric using smoothed landmarks
      const dist = Math.hypot((tip4.x - tip8.x), (tip4.y - tip8.y));
      const mapped = clamp((0.08 - dist) / 0.08, 0, 1);
      const wasPinching = isPinching;
      isPinching = wasPinching ? (mapped > PINCH_OFF) : (mapped > PINCH_ON);
      pinchStrength = mapped;
      // Border glow now reflects only detection state, not pinch/engagement

      // Interaction: draw or drag
      if (pointer.valid) {
        const px2 = pointer.x, py2 = pointer.y;
        if (drawMode) {
          // Pinch to draw
          if (isPinching && !wasPinching) {
            isDrawing = true;
            lastDrawX = px2; lastDrawY = py2;
          }
          if (isPinching && isDrawing) {
            const ctxS = sketchCtx();
            ctxS.save();
            ctxS.lineCap = 'round';
            ctxS.lineJoin = 'round';
            ctxS.lineWidth = brushSize * devicePixelRatio;
            if (eraseMode) {
              ctxS.globalCompositeOperation = 'destination-out';
              ctxS.strokeStyle = 'rgba(0,0,0,1)';
            } else {
              ctxS.globalCompositeOperation = 'source-over';
              ctxS.strokeStyle = brushColor;
            }
            ctxS.beginPath();
            ctxS.moveTo(lastDrawX, lastDrawY);
            ctxS.lineTo(px2, py2);
            ctxS.stroke();
            ctxS.restore();
            lastDrawX = px2; lastDrawY = py2;
          }
          if (!isPinching && wasPinching && isDrawing) {
            isDrawing = false;
          }
        } else {
          // Widgets: pinch to grab/drag, release to toss with inertia
          if (isPinching && grabbedId == null) {
            const hit = pickWidget(px2, py2);
            if (hit != null) {
              const w = widgets.find(v => v.id === hit);
              if (w) {
                grabbedId = hit;
                grabOffsetX = w.x - px2;
                grabOffsetY = w.y - py2;
                // stop motion while grabbing
                w.vx = 0; w.vy = 0;
              }
            }
          }
          if (!isPinching && grabbedId != null) {
            const releasedId = grabbedId;
            grabbedId = null;
            grabOffsetX = 0; grabOffsetY = 0;
            const w = widgets.find(v => v.id === releasedId);
            if (w) { w.vx = 0; w.vy = 0; }
          }
          if (isPinching && grabbedId != null) {
            moveWidget(grabbedId, px2 + grabOffsetX, py2 + grabOffsetY);
          }
        }
      }

  // Draw overlay (pointer and glow)
  drawOverlay(null);
  statusEl.textContent = isPinching ? 'Pinching' : 'Hand detected.';
    } else {
      pointer.valid = false;
      isPinching = false;
      grabbedId = null;
      grabOffsetX = 0; grabOffsetY = 0;
      isDrawing = false;
      statusEl.textContent = 'No hand detected.';
    }
  }

  // Draw overlay (clear when no results)
  if (!results) {
    const octx = overlay.getContext('2d');
    octx.clearRect(0, 0, overlay.width, overlay.height);
    stage.classList.remove('hand-detected');
    // No engaged state — only detection controls border glow
  }

  // Update physics for tossed widgets
  updateWidgetPhysics(dtFrameSec);

  // Always redraw widgets (for smooth drag)
  const ctx = canvas.getContext('2d');
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  drawWidgets(ctx);

  // 3D rendering removed

  requestAnimationFrame(frame);
}

// Camera setup
async function enableCamera() {
  if (cameraStream) return;
  try {
    statusEl.textContent = 'Requesting camera…';
    const preferred = {
      audio: false,
      video: {
        facingMode: 'user',
        width: { ideal: 1280 },
        height: { ideal: 720 }
      }
    };
    cameraStream = await navigator.mediaDevices.getUserMedia(preferred);
    video.srcObject = cameraStream;
    await video.play();
    // Keep video hidden; we only use it for tracking input
    video.classList.add('hidden');
    statusEl.textContent = 'Camera on (video hidden).';
  } catch (err) {
    console.error(err);
    statusEl.innerHTML = `<span class="err">Camera error:</span> ${err?.message || err}`;
  }
}

// Load MediaPipe HandLandmarker (WASM)
async function initHandLandmarker() {
  if (handLandmarker) return;
  statusEl.textContent = 'Loading hand model…';

  // Import ESM for tasks-vision from CDN with fallback + timeout
  const TASKS_VISION_VERSION = '0.10.12';
  const MODULE_URLS = [
    `https://unpkg.com/@mediapipe/tasks-vision@${TASKS_VISION_VERSION}?module`,
    `https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@${TASKS_VISION_VERSION}?module`,
    `https://esm.run/@mediapipe/tasks-vision@${TASKS_VISION_VERSION}`
  ];

  let visionModule = null;
  let lastErr = null;
  for (const url of MODULE_URLS) {
    try {
      statusEl.textContent = `Loading hand model… (module)`;
      visionModule = await withTimeout(import(url), 15000, 'Load tasks-vision module');
      break;
    } catch (err) {
      lastErr = err;
    }
  }
  if (!visionModule) throw lastErr || new Error('Failed to load tasks-vision module');

  const { FilesetResolver, HandLandmarker } = visionModule;

  // Resolve WASM files (try multiple CDNs)
  const WASM_ROOTS = [
    `https://unpkg.com/@mediapipe/tasks-vision@${TASKS_VISION_VERSION}/wasm`,
    `https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@${TASKS_VISION_VERSION}/wasm`
  ];
  let filesetResolver = null;
  lastErr = null;
  for (const root of WASM_ROOTS) {
    try {
      statusEl.textContent = `Loading hand model… (wasm)`;
      filesetResolver = await withTimeout(
        FilesetResolver.forVisionTasks(root),
        15000,
        'Resolve tasks-vision WASM files'
      );
      break;
    } catch (err) {
      lastErr = err;
    }
  }
  if (!filesetResolver) throw lastErr || new Error('Failed to resolve WASM files');

  // Create detector
  statusEl.textContent = 'Loading hand model… (graph)';
  handLandmarker = await withTimeout(
    HandLandmarker.createFromOptions(filesetResolver, {
      baseOptions: {
        modelAssetPath: 'https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task'
      },
      runningMode: 'VIDEO',
      numHands: 1,
      minHandDetectionConfidence: 0.6,
      minHandPresenceConfidence: 0.6,
      minTrackingConfidence: 0.6
    }),
    60000,
    'Create HandLandmarker'
  );

  statusEl.textContent = 'Model ready.';
}

// Wire UI
btnStart.addEventListener('click', async () => {
  btnStart.disabled = true;
  try {
    await enableCamera();
    await initHandLandmarker();
    running = true;
  } catch (err) {
    console.error(err);
    statusEl.innerHTML = `<span class="err">Start error:</span> ${err?.message || err}`;
    running = false;
    btnStart.disabled = false;
  }
});

btnReset.addEventListener('click', () => resetWidgets());
btnSpawn.addEventListener('click', () => {
  const kinds = ['square', 'circle', 'note'];
  const kind = kinds[Math.floor(Math.random() * kinds.length)];
  const x = overlay.width * (0.25 + Math.random() * 0.5);
  const y = overlay.height * (0.25 + Math.random() * 0.5);
  spawnWidget(kind, x, y);
});
btnClear.addEventListener('click', () => clearWidgets());

// Removed label/clock/sticker widget controls

togglePointer.addEventListener('click', () => {
  showPointer = !showPointer;
  togglePointer.dataset.on = String(showPointer);
  togglePointer.setAttribute('aria-pressed', String(showPointer));
});

btnDrawMode.addEventListener('click', () => {
  drawMode = !drawMode;
  btnDrawMode.dataset.on = String(drawMode);
  btnDrawMode.setAttribute('aria-pressed', String(drawMode));
  // Enable eraser only in draw mode
  btnEraser.disabled = !drawMode;
  if (!drawMode) {
    isDrawing = false;
    eraseMode = false;
    btnEraser.dataset.on = 'false';
    btnEraser.setAttribute('aria-pressed', 'false');
  }
});

btnEraser.addEventListener('click', () => {
  if (btnEraser.disabled) return;
  eraseMode = !eraseMode;
  btnEraser.dataset.on = String(eraseMode);
  btnEraser.setAttribute('aria-pressed', String(eraseMode));
});

colorPicker.addEventListener('input', (e) => {
  brushColor = e.target.value || brushColor;
});

brushSizeInput.addEventListener('input', (e) => {
  const v = Number(e.target.value);
  if (!Number.isNaN(v) && v > 0) brushSize = v;
});

// Pointer and smoothing controls
if (pointerSizeInput) {
  pointerSizeInput.addEventListener('input', (e) => {
    const v = Number(e.target.value);
    if (!Number.isNaN(v) && v > 0) pointerRadius = v;
  });
}
if (smoothingCutoffInput) {
  smoothingCutoffInput.addEventListener('input', (e) => {
    const v = Number(e.target.value);
    if (!Number.isNaN(v) && v > 0) {
      ONE_EURO_CFG.minCutoff = v;
      if (lmFilters) {
        for (const f of lmFilters) { f.fx.minCutoff = v; f.fy.minCutoff = v; }
      }
    }
  });
}
if (smoothingBetaInput) {
  smoothingBetaInput.addEventListener('input', (e) => {
    const v = Number(e.target.value);
    if (!Number.isNaN(v) && v >= 0) {
      ONE_EURO_CFG.beta = v;
      if (lmFilters) {
        for (const f of lmFilters) { f.fx.beta = v; f.fy.beta = v; }
      }
    }
  });
}

btnClearSketch.addEventListener('click', () => {
  const sctx = sketch.getContext('2d');
  sctx.clearRect(0, 0, sketch.width, sketch.height);
});

btnSave.addEventListener('click', () => {
  // Compose drawing + widgets into a single PNG (video is excluded)
  const out = document.createElement('canvas');
  out.width = overlay.width;
  out.height = overlay.height;
  const octx = out.getContext('2d');
  // Optional background fill
  octx.fillStyle = '#0b0e15';
  octx.fillRect(0, 0, out.width, out.height);
  // Drawing layer
  octx.drawImage(sketch, 0, 0);
  // Widgets
  drawWidgets(octx);
  const url = out.toDataURL('image/png');
  const a = document.createElement('a');
  a.href = url;
  a.download = 'hand-canvas.png';
  a.click();
});

// Touch/mouse fallback (supports widgets drag or drawing)
let pointerDown = false;
stage.addEventListener('pointerdown', (e) => {
  const rect = overlay.getBoundingClientRect();
  const px = (e.clientX - rect.left) * devicePixelRatio;
  const py = (e.clientY - rect.top) * devicePixelRatio;
  if (drawMode) {
    isDrawing = true; pointerDown = true; lastDrawX = px; lastDrawY = py;
  } else {
    const hit = pickWidget(px, py);
    if (hit != null) {
      grabbedId = hit;
      const w = widgets.find(v => v.id === hit);
      if (w) { grabOffsetX = w.x - px; grabOffsetY = w.y - py; w.vx = 0; w.vy = 0; }
      pointerDown = true;
    }
  }
});
window.addEventListener('pointermove', (e) => {
  if (!pointerDown) return;
  const rect = overlay.getBoundingClientRect();
  const px = (e.clientX - rect.left) * devicePixelRatio;
  const py = (e.clientY - rect.top) * devicePixelRatio;
  if (drawMode && isDrawing) {
    const ctxS = sketch.getContext('2d');
    ctxS.save();
    ctxS.lineCap = 'round';
    ctxS.lineJoin = 'round';
    ctxS.lineWidth = brushSize * devicePixelRatio;
    if (eraseMode) {
      ctxS.globalCompositeOperation = 'destination-out';
      ctxS.strokeStyle = 'rgba(0,0,0,1)';
    } else {
      ctxS.globalCompositeOperation = 'source-over';
      ctxS.strokeStyle = brushColor;
    }
    ctxS.beginPath();
    ctxS.moveTo(lastDrawX, lastDrawY);
    ctxS.lineTo(px, py);
    ctxS.stroke();
    ctxS.restore();
    lastDrawX = px; lastDrawY = py;
  } else if (grabbedId != null) {
    moveWidget(grabbedId, px + grabOffsetX, py + grabOffsetY);
  }
});
window.addEventListener('pointerup', () => {
  if (drawMode) {
    isDrawing = false; pointerDown = false;
  } else {
    const releasedId = grabbedId;
    pointerDown = false; grabbedId = null; grabOffsetX = 0; grabOffsetY = 0;
    const w = widgets.find(v => v.id === releasedId);
    if (w) { w.vx = 0; w.vy = 0; }
  }
});

// Double-click to edit text on note
stage.addEventListener('dblclick', (e) => {
  const rect = overlay.getBoundingClientRect();
  const px = (e.clientX - rect.left) * devicePixelRatio;
  const py = (e.clientY - rect.top) * devicePixelRatio;
  const id = pickWidget(px, py);
  if (id == null) return;
  const w = widgets.find(v => v.id === id);
  if (!w) return;
  if (w.kind === 'note') {
    const t = prompt('Edit text:', w.text || '');
    if (t != null) w.text = t;
  }
});

// Init sizing & default widgets
window.addEventListener('resize', () => { resizeCanvases(); });
resizeCanvases();
// Observe stage size changes to keep canvases perfectly fitted
new ResizeObserver(() => { resizeCanvases(); }).observe(stage);
resetWidgets();
statusEl.textContent = 'Ready. Click “Enable Camera” to start.';
// Start animation loop immediately so widgets render even before camera/model
requestAnimationFrame(frame);
// 3D viewer removed

</script>
</body>
</html>
