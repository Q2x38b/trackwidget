<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
<title>Hand Tracker Canvas ‚Äî Client-Side</title>
<style>
  :root {
    --bg: #0f1115;
    --panel: #151821;
    --text: #e8eaf0;
    --muted: #8b93a7;
    --accent: #5ac8fa;
    --ok: #34c759;
    --warn: #ff9f0a;
  }
  * { box-sizing: border-box; }
  html, body { height: 100%; min-height: 100dvh; margin: 0; background: radial-gradient(1200px 800px at 80% -10%, #121521, #0d0f14 45%, #0a0c10 100%); color: var(--text); font: 14px/1.35 system-ui, -apple-system, Segoe UI, Roboto, Inter, "Helvetica Neue", Arial, sans-serif; }
  .app {
    display: grid; grid-template-rows: auto 1fr auto; gap: 10px; height: 100dvh; padding: 14px; max-width: 100vw; margin: 0 auto;
  }
  header {
    display: flex; gap: 12px; align-items: center; justify-content: space-between;
    background: linear-gradient(180deg, #171a23 0%, #121520 100%); border: 1px solid #22283a; border-radius: 14px; padding: 10px 12px;
    box-shadow: 0 1px 0 rgba(255,255,255,0.04) inset, 0 14px 40px rgba(0,0,0,0.35);
  }
  header .left { display: flex; gap: 10px; align-items: center; }
  .badge {
    border: 1px solid #283047; background: #121728; padding: 6px 10px; border-radius: 999px; color: var(--muted);
  }
  .controls { display: flex; flex-wrap: wrap; gap: 8px; align-items: center; }
  .btn, .toggle {
    appearance: none; border: 1px solid #2a3147; background: #141828; color: var(--text);
    padding: 8px 10px; border-radius: 10px; cursor: pointer; transition: 120ms transform ease, 120ms background ease, 120ms border-color ease;
  }
  .btn:hover, .toggle:hover { transform: translateY(-1px); border-color: #39425e; }
  .btn:active, .toggle:active { transform: translateY(0); }
  .toggle[data-on="true"] { background: #0f1b2e; border-color: #3d6ea3; box-shadow: 0 0 0 1px #284a72 inset; }
  .small { font-size: 12px; color: var(--muted); }
  .stage {
    position: relative; border-radius: 16px; overflow: hidden; background: #0b0e15; border: 1px solid #1b2133;
    box-shadow: 0 0 0 1px rgba(255,255,255,0.02) inset, 0 24px 70px rgba(0,0,0,0.45);
    min-height: 320px;
    height: 100%;
    transition: box-shadow 160ms ease, border-color 160ms ease;
  }
  /* Stage glow states */
  .stage.hand-detected {
    box-shadow: 0 0 0 1px rgba(255,255,255,0.02) inset,
                0 24px 70px rgba(0,0,0,0.45),
                0 0 16px 2px rgba(90,200,250,0.25);
    border-color: #28486e;
  }
  /* Removed pinch/engaged glow ‚Äî border glows only on detection */
  .layer { position: absolute; inset: 0; }
  video { width: 100%; height: 100%; object-fit: cover; filter: saturate(0.95) contrast(1.05) brightness(0.95); transform: scaleX(-1); } /* mirrored for natural UX */
  canvas { width: 100%; height: 100%; display: block; touch-action: none; }
  .overlay {
    pointer-events: none;
  }
  /* Sliders */
  input[type="range"] {
    appearance: none;
    height: 4px;
    background: #1b2133;
    border-radius: 999px;
    outline: none;
    border: 1px solid #2a3147;
  }
  input[type="range"]::-webkit-slider-thumb {
    appearance: none;
    width: 14px; height: 14px; border-radius: 50%;
    background: var(--accent);
    border: 1px solid #2a3147;
    box-shadow: 0 1px 0 rgba(255,255,255,0.05) inset;
  }
  input[type="color"] { height: 28px; width: 36px; border-radius: 6px; border: 1px solid #2a3147; background: #111526; }
  footer {
    display: flex; align-items: center; justify-content: space-between; gap: 10px;
    color: var(--muted);
  }
  .legend { display: flex; gap: 14px; flex-wrap: wrap; }
  .dot { width: 10px; height: 10px; border-radius: 50%; display: inline-block; margin-right: 6px; vertical-align: -1px; }
  .dot.accent { background: var(--accent); }
  .dot.ok { background: var(--ok); }
  .dot.warn { background: var(--warn); }
  .status { color: var(--muted); }
  .err { color: #ff453a; }
  .hidden { display: none !important; }

  /* Widget styling hints for hover/tap */
  .hint {
    position: absolute; top: 12px; right: 12px; background: rgba(0,0,0,0.45); border: 1px solid #2a3147;
    padding: 6px 10px; border-radius: 999px; font-size: 12px; color: #cdd3e2;
    backdrop-filter: blur(8px);
  }
</style>
</head>
<body>
<div class="app">
  <header>
    <div class="left">
      <span class="badge">Hand Tracker</span>
      <div class="small">Pinch thumb + index to interact. Grab with one hand; twist your wrist to rotate; move other hand up/down to resize. Enable Draw Mode to sketch; release to stop.</div>
    </div>
    <div class="controls">
      <button id="btnStart" class="btn">Enable Camera</button>
      <button id="btnReset" class="btn">Reset Widgets</button>
      <button id="btnSpawn" class="btn">Add Widget</button>
      <button id="btnClear" class="btn">Clear Widgets</button>

      <span class="small" style="margin-left:8px;">| 3D</span>
      <button id="btnAddCube" class="btn">Add Cube</button>
      <button id="btnAddSphere" class="btn">Add Sphere</button>
      <button id="toggleRotate3D" class="toggle" data-on="true" aria-pressed="true" title="When on, hand only rotates 3D objects (no 2D rotation)">3D Rotate-only</button>
      <button id="togglePointer" class="toggle" data-on="true" aria-pressed="true">Show Pointer</button>
      <span class="small" style="margin-left:8px;">| Drawing</span>
      <button id="btnDrawMode" class="toggle" data-on="false" aria-pressed="false">Draw Mode</button>
      <button id="btnEraser" class="toggle" data-on="false" aria-pressed="false" disabled>Eraser</button>
      <input id="colorPicker" type="color" value="#ff375f" title="Brush color" />
      <input id="brushSize" type="range" min="2" max="36" value="8" title="Brush size" />
      <button id="btnClearSketch" class="btn">Clear Drawing</button>
      <button id="btnSave" class="btn">Save PNG</button>

      <span class="small" style="margin-left:8px;">| Smooth</span>
      <label class="small" title="Smoothing cutoff (lower = smoother)">
        cutoff
        <input id="smoothingCutoff" type="range" min="0.8" max="4" step="0.1" value="1.4" />
      </label>
      <label class="small" title="Smoothing beta (higher = more responsive)">
        beta
        <input id="smoothingBeta" type="range" min="0" max="1.5" step="0.05" value="0.8" />
      </label>
      <span class="small" style="margin-left:8px;">| Pointer</span>
      <label class="small" title="Pointer size">
        size
        <input id="pointerSize" type="range" min="4" max="20" step="1" value="7" />
      </label>

      <span class="small" style="margin-left:8px;">| Pinch</span>
      <label class="small" title="Pinch sensitivity (higher = easier to trigger)">
        sens
        <input id="pinchSensitivity" type="range" min="0.6" max="1.6" step="0.02" value="1.18" />
      </label>

      <span class="small" style="margin-left:8px;">| Resize</span>
      <button id="toggleSecondHand" class="toggle" data-on="true" aria-pressed="true" title="Allow second hand for resizing">2nd-hand Resize</button>
    </div>
  </header>

  <div class="stage" id="stage">
    <div class="hint">ü§è Grab with one hand; twist wrist to rotate; move other hand up/down to resize</div>
    <video id="video" class="layer hidden" playsinline muted></video>
    <canvas id="webgl" class="layer"></canvas>
    <canvas id="sketch" class="layer"></canvas>
    <canvas id="canvas" class="layer"></canvas>
    <canvas id="overlay" class="layer overlay"></canvas>
  </div>

  <footer>
    <div class="legend">
      <span><span class="dot ok"></span>Pointer</span>
      <span>Pinch to draw (when Draw Mode is on)</span>
    </div>
    <div class="status" id="status">Idle.</div>
  </footer>
</div>

<!-- Hand tracking with MediaPipe Tasks Vision (WASM, fully client-side) -->
<script type="module">
/**
 * Fully client-side hand tracker using MediaPipe Tasks Vision (WASM).
 * - Detects hand landmarks from your webcam.
 * - Uses index fingertip (landmark 8) as a pointer.
 * - Uses thumb tip (4) + index tip (8) distance to detect pinch (grab).
 * - Lets you drag "widgets" (shapes) around a canvas with a pinch gesture.
 *
 * Notes:
 * - All processing happens locally in your browser.
 * - Mirrored video for natural left/right motion.
 */

const statusEl = document.getElementById('status');
const video = document.getElementById('video');
const webgl = document.getElementById('webgl');      // 3D layer
const sketch = document.getElementById('sketch');     // persistent drawing layer
const canvas = document.getElementById('canvas');     // interaction layer (widgets)
const overlay = document.getElementById('overlay');   // pointer & debug
const btnStart = document.getElementById('btnStart');
const btnReset = document.getElementById('btnReset');
const btnSpawn = document.getElementById('btnSpawn');
const btnClear = document.getElementById('btnClear');
const btnAddCube = document.getElementById('btnAddCube');
const btnAddSphere = document.getElementById('btnAddSphere');
const togglePointer = document.getElementById('togglePointer');
const toggleRotate3D = document.getElementById('toggleRotate3D');
const btnDrawMode = document.getElementById('btnDrawMode');
const btnEraser = document.getElementById('btnEraser');
const colorPicker = document.getElementById('colorPicker');
const brushSizeInput = document.getElementById('brushSize');
const btnClearSketch = document.getElementById('btnClearSketch');
const btnSave = document.getElementById('btnSave');
const smoothingCutoffInput = document.getElementById('smoothingCutoff');
const smoothingBetaInput = document.getElementById('smoothingBeta');
const pointerSizeInput = document.getElementById('pointerSize');
const stage = document.getElementById('stage');
const toggleSecondHand = document.getElementById('toggleSecondHand');

let showPointer = true;
let handLandmarker = null;
let cameraStream = null;
let running = false;
let lastVideoTime = -1;
let allowSecondHand = true;
let rotate3DOnly = true; // when true, wrist twist rotates only 3D objects (2D widgets won't rotate)

// Three.js state
let THREE_NS = null; // assigned after dynamic import
const three = {
  scene: null,
  camera: null,
  renderer: null,
  raycaster: null,
  objects: [], // interactive meshes
  hovered: null,
};

// Lightweight 3D interaction state so the rest of the app doesn't crash
const threeState = {
  grabbed: false,
  grabbedObj: null,
  handIdx: null,
  basePalmQuat: null,   // {x,y,z,w} at grab start
  baseObjQuat: null,    // THREE.Quaternion clone at grab start
  baseAngle: 0,         // 2D palm roll angle at grab start (fallback)
  baseObjEulerZ: 0,     // object euler z at grab start (fallback)
};

// --- 3D math helpers for stable palm orientation ---
function sub3(a, b) { return { x: a.x - b.x, y: a.y - b.y, z: a.z - b.z }; }
function dot3(a, b) { return a.x * b.x + a.y * b.y + a.z * b.z; }
function cross3(a, b) {
  return {
    x: a.y * b.z - a.z * b.y,
    y: a.z * b.x - a.x * b.z,
    z: a.x * b.y - a.y * b.x,
  };
}
function norm3(v) {
  const m = Math.hypot(v.x, v.y, v.z) || 1;
  return { x: v.x / m, y: v.y / m, z: v.z / m };
}
function quatFromBasis(x, y, z) {
  const m00 = x.x, m01 = y.x, m02 = z.x;
  const m10 = x.y, m11 = y.y, m12 = z.y;
  const m20 = x.z, m21 = y.z, m22 = z.z;
  const t = m00 + m11 + m22;
  let qw, qx, qy, qz;
  if (t > 0) {
    const s = Math.sqrt(t + 1.0) * 2;
    qw = 0.25 * s;
    qx = (m21 - m12) / s;
    qy = (m02 - m20) / s;
    qz = (m10 - m01) / s;
  } else if (m00 > m11 && m00 > m22) {
    const s = Math.sqrt(1.0 + m00 - m11 - m22) * 2;
    qw = (m21 - m12) / s;
    qx = 0.25 * s;
    qy = (m01 + m10) / s;
    qz = (m02 + m20) / s;
  } else if (m11 > m22) {
    const s = Math.sqrt(1.0 + m11 - m00 - m22) * 2;
    qw = (m02 - m20) / s;
    qx = (m01 + m10) / s;
    qy = 0.25 * s;
    qz = (m12 + m21) / s;
  } else {
    const s = Math.sqrt(1.0 + m22 - m00 - m11) * 2;
    qw = (m10 - m01) / s;
    qx = (m02 + m20) / s;
    qy = (m12 + m21) / s;
    qz = 0.25 * s;
  }
  return { x: qx, y: qy, z: qz, w: qw };
}
function normalizeQuat(q) {
  const m = Math.hypot(q.x, q.y, q.z, q.w) || 1;
  return { x: q.x / m, y: q.y / m, z: q.z / m, w: q.w / m };
}
function slerpQuat(a, b, t) {
  // Ensure shortest path
  let dot = a.x * b.x + a.y * b.y + a.z * b.z + a.w * b.w;
  let bx = b.x, by = b.y, bz = b.z, bw = b.w;
  if (dot < 0) { dot = -dot; bx = -bx; by = -by; bz = -bz; bw = -bw; }
  if (dot > 0.9995) {
    // Nearly linear
    const out = {
      x: a.x + t * (bx - a.x), y: a.y + t * (by - a.y), z: a.z + t * (bz - a.z), w: a.w + t * (bw - a.w)
    };
    return normalizeQuat(out);
  }
  const theta0 = Math.acos(clamp(dot, -1, 1));
  const theta = theta0 * t;
  const sinTheta = Math.sin(theta);
  const sinTheta0 = Math.sin(theta0);
  const s0 = Math.cos(theta) - dot * sinTheta / sinTheta0;
  const s1 = sinTheta / sinTheta0;
  return normalizeQuat({
    x: (s0 * a.x) + (s1 * bx),
    y: (s0 * a.y) + (s1 * by),
    z: (s0 * a.z) + (s1 * bz),
    w: (s0 * a.w) + (s1 * bw),
  });
}

// Compute a stable palm orientation quaternion using multiple MCP/tip points
function computePalmQuaternion(worldLandmarks, smoothed2D, prevQuat) {
  try {
    if (worldLandmarks && worldLandmarks.length >= 18) {
      const w = worldLandmarks;
      const wrist = w[0];
      const indexMcp = w[5];
      const pinkyMcp = w[17];
      const middleMcp = w[9];
      const middleTip = w[12];

      // Primary axis across the knuckles (pinky->index)
      const xAxis = norm3(sub3(indexMcp, pinkyMcp));
      // Forward axis approximated by middle finger direction; fallback to wrist->middle
      let vFwd = norm3(sub3(middleTip, middleMcp));
      if (!Number.isFinite(vFwd.x) || !Number.isFinite(vFwd.y) || !Number.isFinite(vFwd.z)) {
        vFwd = norm3(sub3(middleMcp, wrist));
      }
      // Palm normal via cross; enforce right-handed basis
      let zAxis = norm3(cross3(xAxis, vFwd));
      // If degenerate, fallback using wrist->index
      if (!Number.isFinite(zAxis.x) || !Number.isFinite(zAxis.y) || !Number.isFinite(zAxis.z)) {
        const alt = norm3(sub3(indexMcp, wrist));
        zAxis = norm3(cross3(xAxis, alt));
      }
      let yAxis = norm3(cross3(zAxis, xAxis));

      // Compose quaternion from basis
      let qNow = quatFromBasis(xAxis, yAxis, zAxis);
      qNow = normalizeQuat(qNow);

      // Smooth orientation to reduce jitter
      if (prevQuat) {
        qNow = slerpQuat(prevQuat, qNow, PALM_SLERP_ALPHA);
      }
      return qNow;
    }
  } catch (_) {
    // fall through to identity
  }
  return prevQuat || { x: 0, y: 0, z: 0, w: 1 };
}

// Lazy-load three.js from CDN; proceed gracefully if it fails
async function loadThree() {
  const CDN_CANDIDATES = [
    'https://unpkg.com/three@0.157.0/build/three.module.js',
    'https://cdn.jsdelivr.net/npm/three@0.157.0/build/three.module.js',
    'https://esm.run/three@0.157.0'
  ];
  for (const url of CDN_CANDIDATES) {
    try {
      THREE_NS = await withTimeout(import(url), 10000, 'Load three.js');
      return;
    } catch (_) {
      // try next
    }
  }
  // If we cannot load three.js, keep THREE_NS as null ‚Äî all 3D paths will no-op
  THREE_NS = null;
}

function initThree() {
  if (!THREE_NS) return;
  // Basic scene/camera/renderer
  three.scene = new THREE_NS.Scene();
  const rect = stage.getBoundingClientRect();
  three.camera = new THREE_NS.PerspectiveCamera(60, Math.max(1, rect.width) / Math.max(1, rect.height), 0.1, 100);
  three.camera.position.set(0, 0, 3);
  three.renderer = new THREE_NS.WebGLRenderer({ canvas: webgl, antialias: true, alpha: true });
  three.renderer.setPixelRatio(devicePixelRatio);
  three.renderer.setSize(rect.width, rect.height, false);
  three.raycaster = new THREE_NS.Raycaster();
  // Lights
  const ambient = new THREE_NS.AmbientLight(0xffffff, 0.6);
  const dir = new THREE_NS.DirectionalLight(0xffffff, 0.6);
  dir.position.set(1, 2, 3);
  three.scene.add(ambient, dir);
}

function renderThree() {
  if (!THREE_NS || !three.renderer || !three.scene || !three.camera) return;
  three.renderer.render(three.scene, three.camera);
}

function spawn3D(kind = 'cube') {
  if (!THREE_NS || !three.scene) return;
  let mesh;
  if (kind === 'sphere') {
    mesh = new THREE_NS.Mesh(
      new THREE_NS.SphereGeometry(0.25, 32, 16),
      new THREE_NS.MeshStandardMaterial({ color: 0x5ac8fa, metalness: 0.1, roughness: 0.35 })
    );
  } else {
    mesh = new THREE_NS.Mesh(
      new THREE_NS.BoxGeometry(0.4, 0.4, 0.4),
      new THREE_NS.MeshStandardMaterial({ color: 0x34c759, metalness: 0.1, roughness: 0.45 })
    );
  }
  mesh.position.set((Math.random() - 0.5) * 1.4, (Math.random() - 0.5) * 0.9, 0);
  mesh.castShadow = false;
  mesh.receiveShadow = false;
  three.scene.add(mesh);
  three.objects.push(mesh);
}

function raycast3DFromPixels(px, py) {
  if (!THREE_NS || !three.camera || !three.renderer || !three.raycaster) return null;
  const rect = webgl.getBoundingClientRect();
  const nx = (px / (rect.width * devicePixelRatio)) * 2 - 1;
  const ny = -(py / (rect.height * devicePixelRatio)) * 2 + 1;
  three.raycaster.setFromCamera({ x: nx, y: ny }, three.camera);
  const hits = three.raycaster.intersectObjects(three.objects, false);
  return hits.length ? hits[0].object : null;
}

function beginThreeGrab(handIdx, object3D, opts = {}) {
  if (!object3D) return;
  threeState.grabbed = true;
  threeState.grabbedObj = object3D;
  threeState.handIdx = handIdx;
  const h = (handIdx == null) ? null : hands[handIdx];
  // Cache baselines for rotation
  if (THREE_NS && object3D) {
    threeState.baseObjQuat = object3D.quaternion.clone();
    threeState.baseObjEulerZ = object3D.rotation.z;
  } else {
    threeState.baseObjQuat = null;
    threeState.baseObjEulerZ = 0;
  }
  threeState.basePalmQuat = h?.quat ? { x: h.quat.x, y: h.quat.y, z: h.quat.z, w: h.quat.w } : null;
  threeState.baseAngle = h?.angle || 0;
}

function updateThreeDragFromPixels(px, py) {
  // Optional: implement screen-space dragging. For now, keep as no-op unless rotate3DOnly is disabled.
  if (!THREE_NS || !threeState.grabbed || !threeState.grabbedObj) return;
}

function endThreeGrab() {
  threeState.grabbed = false;
  threeState.grabbedObj = null;
  threeState.handIdx = null;
  threeState.basePalmQuat = null;
  threeState.baseObjQuat = null;
  threeState.baseAngle = 0;
  threeState.baseObjEulerZ = 0;
}

function handleThreeInteractions(results) {
  if (!THREE_NS || !three.objects.length) return;

  // Helper to rotate grabbed object according to current hand orientation
  const applyRotationFromHand = (h) => {
    if (!threeState.grabbed || !threeState.grabbedObj) return;
    // Prefer full palm quaternion if available; else fall back to 2D roll angle around camera Z
    if (h?.quat && threeState.basePalmQuat && threeState.baseObjQuat) {
      const qBasePalm = new THREE_NS.Quaternion(
        threeState.basePalmQuat.x,
        threeState.basePalmQuat.y,
        threeState.basePalmQuat.z,
        threeState.basePalmQuat.w
      );
      const qNowPalm = new THREE_NS.Quaternion(h.quat.x, h.quat.y, h.quat.z, h.quat.w);
      // Relative rotation in camera space: qRel = qNow * inverse(qBase)
      const qRel = qNowPalm.clone().multiply(qBasePalm.clone().invert());
      // Apply delta before base to rotate in world axes
      const out = qRel.clone().multiply(threeState.baseObjQuat);
      threeState.grabbedObj.quaternion.copy(out);
    } else {
      // Fallback: twist around camera Z using 2D palm angle
      const curAngle = h?.angle || 0;
      const delta = wrapAngle(curAngle - (threeState.baseAngle || 0));
      threeState.grabbedObj.rotation.z = threeState.baseObjEulerZ + delta;
    }
  };

  // 1) If currently grabbed: update or release
  if (threeState.grabbed) {
    const hi = threeState.handIdx;
    const h = (hi == null) ? null : hands[hi];
    if (!h || !h.valid || !h.isPinching) {
      endThreeGrab();
      return;
    }
    applyRotationFromHand(h);
    return;
  }

  // 2) Not grabbed: look for pinch-start over a 3D object
  for (let i = 0; i < MAX_HANDS; i++) {
    const h = hands[i];
    if (!h || !h.valid) continue;
    // Start only on fresh pinch onset to avoid sticky grabs
    if (h.isPinching && !h.wasPinching) {
      // Raycast from pointer position
      const px = h.x, py = h.y;
      const hit = raycast3DFromPixels(px, py);
      if (hit) {
        beginThreeGrab(i, hit, { px, py });
        return; // grab only one per frame
      }
    }
  }
}

// Pointer + landmark smoothing (One Euro filter) ‚Äî multi-hand
const MAX_HANDS = 2;
/** @typedef {{
 *  x:number,y:number,valid:boolean,
 *  lmFilters:null|Array<{fx:OneEuro1D,fy:OneEuro1D}>,
 *  isPinching:boolean,wasPinching:boolean,pinchStrength:number,rawPinchDist:number,
 *  pinchFiltered:number,
 *  prevRawX?:number, prevRawY?:number, gain?:number, angle?:number,
 *  world?: Array<{x:number,y:number,z:number}>|null, quat?: any
 * }} HandState */
/** @type {Array<HandState>} */
let hands = Array.from({ length: MAX_HANDS }, () => ({
  x: 0, y: 0, valid: false,
  lmFilters: null,
  isPinching: false,
  wasPinching: false,
  pinchStrength: 0,
  rawPinchDist: 0,
  pinchOnCount: 0,
  pinchOffCount: 0,
  pinchFiltered: 0,
}));
let lastFilterTime = null;
const ONE_EURO_CFG = { minCutoff: 1.4, beta: 0.8, dCutoff: 1.0 };

// Pinch detection thresholds and debounce (tuned for better responsiveness)
// Smoother signal + slightly lower ON threshold + shorter debounce
const PINCH_ON = 0.50;
const PINCH_OFF = 0.42;
const PINCH_ON_FRAMES = 2;  // consecutive frames required to start pinch
const PINCH_OFF_FRAMES = 2; // consecutive frames required to end pinch
// Reference ratio for 3D pinch metric: when index-thumb distance equals
// PINCH_REF_RATIO3D * palmWidth3D, pinchStrength‚âà0. Higher makes pinch easier to trigger.
const PINCH_REF_RATIO3D = 0.82;
// Multi-cue pinch scoring weights (proximity vs. finger alignment)
const PINCH_PROX_WEIGHT = 0.65;
const PINCH_ALIGN_WEIGHT = 0.35;
// Palm quaternion temporal smoothing for stable 3D rotation
const PALM_SLERP_ALPHA = 0.25;

// Widgets state
/**
 * @typedef {'square'|'circle'|'note'} WidgetKind
 * @typedef {{id:number, x:number, y:number, w:number, h:number, kind:WidgetKind, vx?:number, vy?:number, text?:string}} Widget
 */
/** @type {Array<Widget>} */
let widgets = [];
let grabbedId = null;
let grabHand = null;        // 0 or 1
// Resize with the other hand's pinch-open distance
let resizeHand = null;      // 0 or 1 (the non-grabbing hand)
let resizeBaseDist = 0;     // normalized distance at start of resize (legacy)
let resizeBaseW = 0, resizeBaseH = 0; // widget size at start of resize
let resizeStartY = 0;       // vertical baseline for up/down resize
let nextId = 1;
// Rotation state while grabbing
let grabStartAngle = 0;
let grabStartRot = 0;

// Drawing state
let drawMode = false;
let eraseMode = false;
let isDrawing = false;
let lastDrawX = 0, lastDrawY = 0;
let brushColor = '#ff375f';
let brushSize = 8; // CSS px (will be scaled by devicePixelRatio)
const sketchCtx = () => sketch.getContext('2d');
let lastDoubleClick = 0;

// Pointer visuals and smoothing controls
let pointerRadius = 7; // CSS px

// Fit canvases to stage size
function resizeCanvases() {
  const rect = stage.getBoundingClientRect();
  for (const el of [webgl, sketch, canvas, overlay]) {
    el.width = Math.floor(rect.width * devicePixelRatio);
    el.height = Math.floor(rect.height * devicePixelRatio);
    el.style.width = rect.width + 'px';
    el.style.height = rect.height + 'px';
  }
  // Update 3D renderer size and camera aspect
  if (three.renderer && three.camera) {
    three.renderer.setPixelRatio(devicePixelRatio);
    three.renderer.setSize(rect.width, rect.height, false);
    three.camera.aspect = rect.width / rect.height;
    three.camera.updateProjectionMatrix();
  }
}

// Utility: lerp
const lerp = (a, b, t) => a + (b - a) * t;

// Utility: clamp
const clamp = (v, a, b) => Math.max(a, Math.min(b, v));

// Promise timeout helper
function withTimeout(promise, ms, label) {
  return new Promise((resolve, reject) => {
    const t = setTimeout(() => reject(new Error(`${label} timed out after ${Math.round(ms/1000)}s`)), ms);
    promise.then(
      (v) => { clearTimeout(t); resolve(v); },
      (err) => { clearTimeout(t); reject(err); }
    );
  });
}

// Map normalized landmark (0..1) to overlay pixel coords (already devicePixelRatio scaled)
function normToPx(nx, ny) {
  // Video is mirrored (scaleX(-1)), so flip X for more intuitive pointer
  const px = (1 - nx) * overlay.width;
  const py = ny * overlay.height;
  return [px, py];
}

// Angle helpers
function wrapAngle(a) {
  while (a > Math.PI) a -= Math.PI * 2;
  while (a < -Math.PI) a += Math.PI * 2;
  return a;
}

// One Euro filter implementation for smoother, responsive tracking
class LowPassFilter {
  constructor(alpha = 1.0) {
    this.alpha = alpha;
    this.initialized = false;
    this.s = 0;
  }
  filter(value, alpha = this.alpha) {
    if (!this.initialized) {
      this.initialized = true;
      this.s = value;
      return value;
    }
    this.s = this.s + alpha * (value - this.s);
    return this.s;
  }
  lastValue() { return this.s; }
}

function alphaFor(dt, cutoff) {
  const tau = 1.0 / (2 * Math.PI * cutoff);
  return 1.0 / (1.0 + tau / dt);
}

class OneEuro1D {
  constructor({ minCutoff = 1.7, beta = 0.6, dCutoff = 1.0 } = {}) {
    this.minCutoff = minCutoff;
    this.beta = beta;
    this.dCutoff = dCutoff;
    this.dxFilter = new LowPassFilter();
    this.xFilter = new LowPassFilter();
    this.prevX = null;
  }
  filter(x, dt) {
    const dx = this.prevX == null ? 0 : (x - this.prevX) / dt;
    const edx = this.dxFilter.filter(dx, alphaFor(dt, this.dCutoff));
    const cutoff = this.minCutoff + this.beta * Math.abs(edx);
    const result = this.xFilter.filter(x, alphaFor(dt, cutoff));
    this.prevX = result;
    return result;
  }
}

function ensureLmFiltersForHand(handIdx, count) {
  const hs = hands[handIdx];
  if (hs.lmFilters && hs.lmFilters.length === count) return;
  hs.lmFilters = Array.from({ length: count }, () => ({
    fx: new OneEuro1D(ONE_EURO_CFG),
    fy: new OneEuro1D(ONE_EURO_CFG)
  }));
}

// Widget helpers
function spawnWidget(kind, x, y) {
  const baseSize = Math.max(60, Math.min(overlay.width, overlay.height) * 0.08);
  if (kind === 'circle') {
    widgets.push({ id: nextId++, x, y, w: baseSize, h: baseSize, kind, vx: 0, vy: 0, rot: 0 });
  } else if (kind === 'note') {
    widgets.push({ id: nextId++, x, y, w: baseSize * 1.6, h: baseSize * 1.1, kind, vx: 0, vy: 0, text: 'Note', rot: 0 });
  } else {
    widgets.push({ id: nextId++, x, y, w: baseSize, h: baseSize, kind: 'square', vx: 0, vy: 0, rot: 0 });
  }
}

function resetWidgets() {
  widgets = [];
  const cx = overlay.width * 0.33, cy = overlay.height * 0.55;
  spawnWidget('square', cx - 90, cy);
  spawnWidget('circle', cx + 90, cy - 30);
  spawnWidget('note', cx + 20, cy + 90);
}

function clearWidgets() {
  widgets = [];
}

const HIT_EXPAND = 36 * devicePixelRatio; // base hit target expansion
let grabOffsetX = 0, grabOffsetY = 0;    // preserve offset when grabbing

function dynamicHitExpand(hand) {
  const s = clamp(hand?.pinchStrength ?? 0, 0, 1);
  // Expand with pinch strength and pointer size, making grabs easier when pinching
  const extra = (8 + pointerRadius) * devicePixelRatio * (0.35 + 0.5 * s);
  return HIT_EXPAND + extra;
}

function pickWidget(px, py, expand = HIT_EXPAND) {
  // topmost first ‚Äî iterate from end
  for (let i = widgets.length - 1; i >= 0; i--) {
    const w = widgets[i];
    if (w.kind === 'circle') {
      const dx = px - w.x, dy = py - w.y;
      if (Math.hypot(dx, dy) <= w.w * 0.5 + expand) return w.id;
    } else {
      // square or note are rectangles ‚Äî account for rotation
      const rot = w.rot || 0;
      const dx = px - w.x, dy = py - w.y;
      const cos = Math.cos(-rot), sin = Math.sin(-rot);
      const lx = dx * cos - dy * sin; // rotate point into widget-local frame
      const ly = dx * sin + dy * cos;
      if (
        lx >= -w.w/2 - expand &&
        lx <=  w.w/2 + expand &&
        ly >= -w.h/2 - expand &&
        ly <=  w.h/2 + expand
      ) return w.id;
    }
  }
  return null;
}

function moveWidget(id, px, py) {
  const w = widgets.find(v => v.id === id);
  if (!w) return;
  w.x = clamp(px, w.w/2, overlay.width - w.w/2);
  w.y = clamp(py, w.h/2, overlay.height - w.h/2);
}

// Physics disabled: widgets stay where released
function updateWidgetPhysics(dtSec) {
  // Intentionally no-op to remove inertia/gravity
}

function drawWidgets(ctx) {
  ctx.save();
  ctx.scale(1, 1);
  for (const w of widgets) {
    ctx.save();
    ctx.translate(w.x, w.y);
    if (w.rot) ctx.rotate(w.rot);
    // cards glow
    ctx.shadowColor = 'rgba(0,0,0,0.5)';
    ctx.shadowBlur = 18 * devicePixelRatio;
    ctx.lineWidth = 2 * devicePixelRatio;

    if (w.kind === 'circle') {
      const r = w.w * 0.5;
      const g = (grabbedId === w.id) ? 'rgba(90,200,250,0.9)' : 'rgba(90,200,250,0.35)';
      ctx.beginPath();
      ctx.arc(0, 0, r, 0, Math.PI * 2);
      ctx.fillStyle = 'rgba(20,24,40,0.9)';
      ctx.strokeStyle = g;
      ctx.fill();
      ctx.stroke();
    } else {
      const radius = 14 * devicePixelRatio;
      const ww = w.w, hh = w.h;
      roundRectPath(ctx, -ww/2, -hh/2, ww, hh, radius);
      ctx.fillStyle = 'rgba(20,24,40,0.9)';
      ctx.fill();
      ctx.strokeStyle = (grabbedId === w.id) ? 'rgba(90,200,250,0.9)' : 'rgba(90,200,250,0.35)';
      ctx.stroke();

      // A little header bar for notes
      if (w.kind === 'note') {
        ctx.save();
        ctx.beginPath();
        roundRectPath(ctx, -ww/2, -hh/2, ww, 18 * devicePixelRatio, radius);
        ctx.fillStyle = 'rgba(90,200,250,0.15)';
        ctx.fill();
        ctx.restore();
        // Note text
        drawWidgetText(ctx, w.text || 'Note', ww, hh, { topPadding: 26 * devicePixelRatio });
      }
    }
    ctx.restore();
  }
  ctx.restore();
}

function roundRectPath(ctx, x, y, w, h, r) {
  const rr = Math.min(r, w/2, h/2);
  ctx.beginPath();
  ctx.moveTo(x + rr, y);
  ctx.arcTo(x + w, y, x + w, y + h, rr);
  ctx.arcTo(x + w, y + h, x, y + h, rr);
  ctx.arcTo(x, y + h, x, y, rr);
  ctx.arcTo(x, y, x + w, y, rr);
  ctx.closePath();
}

function drawWidgetText(ctx, text, w, h, opts = {}) {
  const pad = 10 * devicePixelRatio;
  const maxWidth = w - pad * 2;
  const fontPx = Math.max(12 * devicePixelRatio, Math.min(20 * devicePixelRatio, h * 0.28));
  ctx.fillStyle = '#d7deee';
  ctx.font = `${fontPx}px/1.2 system-ui, -apple-system, Segoe UI, Inter, Roboto`;
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  let tx = 0;
  let ty = 0;
  if (opts.center) {
    ty = 0;
  } else {
    ty = -h/2 + pad + fontPx * 0.5 + (opts.topPadding || 0);
  }
  // Simple truncation if too long
  let t = String(text);
  while (ctx.measureText(t).width > maxWidth && t.length > 3) {
    t = t.slice(0, -2) + '‚Ä¶';
  }
  ctx.fillText(t, tx, ty);
}

// Clock widget removed

// Determine which single hand is "primary" when second-hand is disabled
function primaryHandIndex() {
  if (grabHand != null) return grabHand;
  if (hands[0] && hands[0].valid) return 0;
  if (hands[1] && hands[1].valid) return 1;
  return null;
}

// Draw overlay (landmarks, pointer, pinch)
function drawOverlay() {
  const ctx = overlay.getContext('2d');
  ctx.clearRect(0, 0, overlay.width, overlay.height);

  if (!showPointer) return;
  const primary = primaryHandIndex();
  for (let i = 0; i < MAX_HANDS; i++) {
    const h = hands[i];
    if (!h.valid) continue;
    // If second-hand usage is disabled, render only the primary hand pointer
    if (!allowSecondHand && i !== primary) continue;
    ctx.save();
    const r = pointerRadius * devicePixelRatio;
    const hoveringId = pickWidget(h.x, h.y); // default hover expansion
    const isGrabbingHand = grabHand === i && grabbedId != null;
    const engaging = isGrabbingHand || hoveringId != null || h.isPinching;
    if (engaging) {
      ctx.shadowColor = i === grabHand ? 'rgba(90,200,250,0.65)' : 'rgba(52,199,89,0.65)';
      ctx.shadowBlur = 14 * devicePixelRatio;
    }
    ctx.beginPath();
    ctx.arc(h.x, h.y, r, 0, Math.PI * 2);
    ctx.fillStyle = i === grabHand ? '#5ac8fa' : '#34c759';
    ctx.fill();
    // ring
    ctx.beginPath();
    ctx.arc(h.x, h.y, r + 5 * devicePixelRatio, 0, Math.PI * 2);
    ctx.strokeStyle = engaging ? (i === grabHand ? 'rgba(90,200,250,0.5)' : 'rgba(52,199,89,0.5)') : 'rgba(255,255,255,0.18)';
    ctx.lineWidth = 2 * devicePixelRatio;
    ctx.stroke();
    ctx.restore();
  }
}

// Run loop ‚Äî always render widgets; run inference only when ready
let lastFrameTime = null;
async function frame() {
  const now = performance.now();
  const dtFrameSec = lastFrameTime == null ? 1/60 : clamp((now - lastFrameTime) / 1000, 1/240, 0.1);
  lastFrameTime = now;

  let results = null;
  const canDetect = running && handLandmarker && video.readyState >= 2;

  if (canDetect && video.currentTime !== lastVideoTime) {
    lastVideoTime = video.currentTime;
    results = handLandmarker.detectForVideo(video, now);

    // Reset validity for this frame
    for (let i = 0; i < MAX_HANDS; i++) {
      hands[i].valid = false;
      hands[i].wasPinching = hands[i].isPinching;
    }

    if (results?.landmarks?.length) {
      // dt in seconds for One Euro filter
      let dt = 1 / 60;
      if (lastFilterTime != null) {
        dt = (now - lastFilterTime) / 1000;
        dt = clamp(dt, 1 / 240, 0.1);
      }
      lastFilterTime = now;

      // For up to MAX_HANDS, smooth and populate state
      for (let i = 0; i < Math.min(MAX_HANDS, results.landmarks.length); i++) {
        const lms = results.landmarks[i];
        ensureLmFiltersForHand(i, lms.length);
        const filters = hands[i].lmFilters;
        const smoothed = lms.map((p, j) => ({
          x: filters[j].fx.filter(p.x, dt),
          y: filters[j].fy.filter(p.y, dt),
        }));
        const tip8 = smoothed[8];
        const tip4 = smoothed[4];
        const [rawPx, rawPy] = normToPx(tip8.x, tip8.y);
        const h = hands[i];
        // Orientation + palm reference
        const mcp5 = smoothed[5];
        const mcp17 = smoothed[17];
        const palmWidth = Math.hypot(mcp5.x - mcp17.x, mcp5.y - mcp17.y) || 0.001;
        h.angle = Math.atan2(mcp17.y - mcp5.y, mcp17.x - mcp5.x);
        // Store world landmarks if available for 3D orientation
        h.world = results.worldLandmarks?.[i] || null;
        // Depth-invariant pointer gain using palm size
        if (h.prevRawX == null || h.prevRawY == null) {
          h.prevRawX = rawPx; h.prevRawY = rawPy;
          h.x = clamp(rawPx, 0, overlay.width);
          h.y = clamp(rawPy, 0, overlay.height);
          h.gain = 1.0;
        } else {
          const dx = rawPx - h.prevRawX;
          const dy = rawPy - h.prevRawY;
          h.prevRawX = rawPx; h.prevRawY = rawPy;
          const TARGET_PALM = 0.095; // constant mapping across depth
          const desiredGain = clamp(TARGET_PALM / palmWidth, 0.7, 2.2);
          h.gain = h.gain == null ? desiredGain : lerp(h.gain, desiredGain, 0.25);
          h.x = clamp((h.x ?? rawPx) + dx * h.gain, 0, overlay.width);
          h.y = clamp((h.y ?? rawPy) + dy * h.gain, 0, overlay.height);
        }
        h.valid = true;

        // Orientation-invariant pinch metric with multi-cue scoring
        // Prefer 3D world landmark distances + alignment; fallback to 2D distance
        const dist2D = Math.hypot((tip4.x - tip8.x), (tip4.y - tip8.y)); // normalized image-space
        let pinchInput = 0;
        if (h.world && h.world.length >= 18) {
          const w4 = h.world[4], w8 = h.world[8], w5 = h.world[5], w17w = h.world[17];
          const dx = w4.x - w8.x, dy = w4.y - w8.y, dz = w4.z - w8.z;
          const dist3D = Math.hypot(dx, dy, dz);
          const pwx = w5.x - w17w.x, pwy = w5.y - w17w.y, pwz = w5.z - w17w.z;
          const palmWidth3D = Math.hypot(pwx, pwy, pwz) || 1e-6;
          // Proximity score: 1 at full pinch, 0 when apart by ref ratio
          const prox = clamp(1 - (dist3D / (palmWidth3D * PINCH_REF_RATIO3D)), 0, 1);
          // Alignment score: thumb/index tips facing each other (opposite directions) along the line connecting them
          const w3 = h.world[3], w7 = h.world[7]; // DIP joints
          const vThumb = { x: w4.x - w3.x, y: w4.y - w3.y, z: w4.z - w3.z };
          const vIndex = { x: w8.x - w7.x, y: w8.y - w7.y, z: w8.z - w7.z };
          const vTI = { x: w8.x - w4.x, y: w8.y - w4.y, z: w8.z - w4.z };
          const nvThumb = (() => { const m = Math.hypot(vThumb.x, vThumb.y, vThumb.z) || 1; return { x: vThumb.x/m, y: vThumb.y/m, z: vThumb.z/m }; })();
          const nvIndex = (() => { const m = Math.hypot(vIndex.x, vIndex.y, vIndex.z) || 1; return { x: vIndex.x/m, y: vIndex.y/m, z: vIndex.z/m }; })();
          const nvTI = (() => { const m = Math.hypot(vTI.x, vTI.y, vTI.z) || 1; return { x: vTI.x/m, y: vTI.y/m, z: vTI.z/m }; })();
          // Want thumb pointing toward index (nvThumb ¬∑ nvTI ‚âà 1) and index pointing toward thumb (nvIndex ¬∑ -nvTI ‚âà 1)
          const a1 = clamp(nvThumb.x*nvTI.x + nvThumb.y*nvTI.y + nvThumb.z*nvTI.z, -1, 1);
          const a2 = clamp(nvIndex.x*(-nvTI.x) + nvIndex.y*(-nvTI.y) + nvIndex.z*(-nvTI.z), -1, 1);
          const align = clamp((a1 + a2) * 0.5 * 0.5 + 0.5, 0, 1); // map [-1,1] avg to [0,1]
          pinchInput = clamp(PINCH_PROX_WEIGHT * prox + PINCH_ALIGN_WEIGHT * align, 0, 1);
          // Store a unitless distance ratio for potential debugging/telemetry
          h.rawPinchDist = dist3D / palmWidth3D;
        } else {
          // 2D fallback, normalized by 2D palm width
          const baseline2D = clamp(palmWidth * 0.48, 0.045, 0.13);
          const raw2D = clamp((baseline2D - dist2D) / baseline2D, 0, 1);
          pinchInput = raw2D;
          h.rawPinchDist = dist2D; // keep legacy unit when 3D unavailable
        }

        // Low-pass the pinch scalar to reduce flicker, but keep responsive
        const alpha = 0.35; // higher = more responsive; tuned via tests
        h.pinchFiltered = (h.pinchFiltered == null) ? pinchInput : (h.pinchFiltered + alpha * (pinchInput - h.pinchFiltered));
        const mapped = h.pinchFiltered;
        const was = h.wasPinching;

        // Debounced hysteresis
        if (mapped > PINCH_ON) {
          h.pinchOnCount = Math.min(h.pinchOnCount + 1, 10);
        } else {
          h.pinchOnCount = 0;
        }
        if (mapped <= PINCH_OFF) {
          h.pinchOffCount = Math.min(h.pinchOffCount + 1, 10);
        } else {
          h.pinchOffCount = 0;
        }
        if (!was) {
          h.isPinching = h.pinchOnCount >= PINCH_ON_FRAMES;
        } else {
          h.isPinching = !(h.pinchOffCount >= PINCH_OFF_FRAMES);
        }
        h.pinchStrength = mapped;

        // Estimate a palm orientation quaternion for 3D mapping
        h.quat = computePalmQuaternion(h.world, smoothed, h.quat);
      }

      // Interaction
      const anyValid = hands.some(h => h.valid);
      stage.classList.toggle('hand-detected', anyValid);
      if (anyValid) {
        if (drawMode) {
          // Use dominant hand: grabbing hand if present, else first valid
          const dom = grabHand != null ? grabHand : (hands[0].valid ? 0 : (hands[1].valid ? 1 : null));
          if (dom != null) {
            const px2 = hands[dom].x, py2 = hands[dom].y;
            const wasPinching = hands[dom].wasPinching;
            const nowPinching = hands[dom].isPinching;
            if (nowPinching && !wasPinching) {
              isDrawing = true;
              lastDrawX = px2; lastDrawY = py2;
            }
            if (nowPinching && isDrawing) {
              const ctxS = sketchCtx();
              ctxS.save();
              ctxS.lineCap = 'round';
              ctxS.lineJoin = 'round';
              ctxS.lineWidth = brushSize * devicePixelRatio;
              if (eraseMode) {
                ctxS.globalCompositeOperation = 'destination-out';
                ctxS.strokeStyle = 'rgba(0,0,0,1)';
              } else {
                ctxS.globalCompositeOperation = 'source-over';
                ctxS.strokeStyle = brushColor;
              }
              ctxS.beginPath();
              ctxS.moveTo(lastDrawX, lastDrawY);
              ctxS.lineTo(px2, py2);
              ctxS.stroke();
              ctxS.restore();
              lastDrawX = px2; lastDrawY = py2;
            }
            if (!nowPinching && wasPinching && isDrawing) {
              isDrawing = false;
            }
          }
        } else {
          // 3D interactions first, then 2D widgets if no 3D grab
          handleThreeInteractions(results);

          // If no 3D object is grabbed, enable 2D widgets: grab with one hand; resize with the other (if enabled)
          if (!threeState.grabbed && grabbedId == null) {
            // Look for any active pinch over a widget on allowed hand(s)
            const primary = primaryHandIndex();
            const candidates = allowSecondHand ? [0, 1] : (primary != null ? [primary] : []);
            for (const i of candidates) {
              const h = hands[i];
              if (!h || !h.valid) continue;
              // begin 2D grab only on pinch onset and only if not on a 3D object
              if (h.isPinching && !h.wasPinching) {
                const hit = pickWidget(h.x, h.y, dynamicHitExpand(h));
                if (hit != null) {
                  const w = widgets.find(v => v.id === hit);
                  if (w) {
                    grabbedId = hit;
                    grabHand = i;
                    grabOffsetX = w.x - h.x;
                    grabOffsetY = w.y - h.y;
                    w.vx = 0; w.vy = 0;
                    // initialize rotation baseline on grab
                    grabStartAngle = hands[i].angle || 0;
                    grabStartRot = w.rot || 0;
                  }
                  break;
                }
              }
            }
          }

          if (grabbedId != null && grabHand != null && !threeState.grabbed) {
            const gh = hands[grabHand];
            const w = widgets.find(v => v.id === grabbedId);
            if (!w) {
              grabbedId = null; grabHand = null; resizeHand = null;
            } else {
              // Move while grab hand keeps pinching
              if (gh.isPinching) {
                moveWidget(grabbedId, gh.x + grabOffsetX, gh.y + grabOffsetY);
                // Rotate with wrist twist while grabbing (disabled when rotate3DOnly is true)
                if (!rotate3DOnly) {
                  const curAngle = gh.angle || 0;
                  const delta = wrapAngle(curAngle - grabStartAngle);
                  const ROT_GAIN = 1.0;
                  w.rot = wrapAngle((grabStartRot || 0) + delta * ROT_GAIN);
                }
              } else {
                // Release
                const releasedId = grabbedId;
                grabbedId = null; grabHand = null; grabOffsetX = 0; grabOffsetY = 0;
                const ww = widgets.find(v => v.id === releasedId);
                if (ww) { ww.vx = 0; ww.vy = 0; }
                resizeHand = null;
              }

              // Resize with the other hand ‚Äî vertical movement up/down
              if (grabbedId != null) {
                const other = grabHand === 0 ? 1 : 0;
                const oh = hands[other];
                if (oh && oh.valid) {
                  const minSize = 40 * devicePixelRatio;
                  const maxSize = Math.min(overlay.width, overlay.height) * 0.8;
                  if (allowSecondHand && other !== grabHand && oh.isPinching) {
                    if (resizeHand == null && !oh.wasPinching) {
                      // Begin resize
                      resizeHand = other;
                      resizeStartY = oh.y;
                      resizeBaseW = w.w;
                      resizeBaseH = w.h;
                    }
                    if (resizeHand === other) {
                      const dy = (resizeStartY - oh.y) / (overlay.height); // up is negative y in pixels? Our coords increase downward, so up -> smaller y -> positive (startY - y)
                      const scale = clamp(1 + dy * 2.0, 0.4, 3.0); // sensitivity 2.0x screen height
                      w.w = clamp(resizeBaseW * scale, minSize, maxSize);
                      // keep aspect ratio for each widget
                      const aspect = resizeBaseH / Math.max(1, resizeBaseW);
                      w.h = clamp(w.w * aspect, minSize * 0.6, maxSize);
                    }
                  } else if (resizeHand === other) {
                    // End resize on release
                    resizeHand = null;
                  }
                } else {
                  resizeHand = null;
                }
              }
            }
          }
        }
      }

      // Overlay + status
      drawOverlay();
      if (threeState.grabbed) {
        statusEl.textContent = rotate3DOnly ? 'Rotating 3D' : 'Manipulating 3D';
      } else if (grabbedId != null && resizeHand != null) {
        statusEl.textContent = 'Resizing';
      } else if (grabbedId != null) {
        statusEl.textContent = 'Grabbing';
      } else if (hands.some((h, idx) => h.isPinching && (allowSecondHand || idx === primaryHandIndex()))) {
        statusEl.textContent = 'Pinching';
      } else {
        statusEl.textContent = 'Hand detected.';
      }
    } else {
      for (let i = 0; i < MAX_HANDS; i++) {
        hands[i].valid = false;
        hands[i].isPinching = false;
        hands[i].pinchOnCount = 0;
        hands[i].pinchOffCount = 0;
        hands[i].prevRawX = undefined;
        hands[i].prevRawY = undefined;
        hands[i].gain = 1.0;
      }
      grabbedId = null;
      grabOffsetX = 0; grabOffsetY = 0;
      grabHand = null; resizeHand = null;
      isDrawing = false;
      statusEl.textContent = 'No hand detected.';
      // Hide pointer immediately when no hands detected in this frame
      const octx = overlay.getContext('2d');
      octx.clearRect(0, 0, overlay.width, overlay.height);
      stage.classList.remove('hand-detected');
    }
  }

  // Draw overlay (clear when no results)
  if (!results) {
    const octx = overlay.getContext('2d');
    octx.clearRect(0, 0, overlay.width, overlay.height);
    stage.classList.remove('hand-detected');
    // No engaged state ‚Äî only detection controls border glow
  }

  // Update physics for tossed widgets
  updateWidgetPhysics(dtFrameSec);

  // Always redraw widgets (for smooth drag)
  const ctx = canvas.getContext('2d');
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  drawWidgets(ctx);

  // 3D rendering
  renderThree();

  requestAnimationFrame(frame);
}

// Camera setup
async function enableCamera() {
  if (cameraStream) return;
  try {
    // Helpful compatibility notice
    if (!('mediaDevices' in navigator) || !('getUserMedia' in navigator.mediaDevices)) {
      throw new Error('Camera API not available. Use a modern browser (Chrome, Edge, Safari).');
    }
    if (!window.isSecureContext && !/^(localhost|127\.0\.0\.1|\[::1\])$/.test(location.hostname)) {
      statusEl.innerHTML = '<span class="err">Insecure context:</span> camera requires HTTPS or localhost.';
    }
    statusEl.textContent = 'Requesting camera‚Ä¶';
    const preferred = {
      audio: false,
      video: {
        facingMode: 'user',
        width: { ideal: 1280 },
        height: { ideal: 720 }
      }
    };
    cameraStream = await navigator.mediaDevices.getUserMedia(preferred);
    video.srcObject = cameraStream;
    await video.play();
    // Keep video hidden; we only use it for tracking input
    video.classList.add('hidden');
    statusEl.textContent = 'Camera on (video hidden).';
  } catch (err) {
    console.error(err);
    const msg = err?.message || String(err);
    if (/denied|not allowed|permission/i.test(msg)) {
      statusEl.innerHTML = '<span class="err">Camera blocked:</span> grant permission and retry.';
    } else if (/insecure|https/i.test(msg)) {
      statusEl.innerHTML = '<span class="err">Use HTTPS or localhost for camera access.</span>';
    } else {
      statusEl.innerHTML = `<span class="err">Camera error:</span> ${msg}`;
    }
  }
}

// Load MediaPipe HandLandmarker (WASM)
async function initHandLandmarker() {
  if (handLandmarker) return;
  statusEl.textContent = 'Loading hand model‚Ä¶';

  // Import ESM for tasks-vision from CDN with fallback + timeout
  const TASKS_VISION_VERSION = '0.10.12';
  const MODULE_URLS = [
    `https://unpkg.com/@mediapipe/tasks-vision@${TASKS_VISION_VERSION}?module`,
    `https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@${TASKS_VISION_VERSION}?module`,
    `https://esm.run/@mediapipe/tasks-vision@${TASKS_VISION_VERSION}`
  ];

  let visionModule = null;
  let lastErr = null;
  for (const url of MODULE_URLS) {
    try {
      statusEl.textContent = `Loading hand model‚Ä¶ (module)`;
      visionModule = await withTimeout(import(url), 15000, 'Load tasks-vision module');
      break;
    } catch (err) {
      lastErr = err;
    }
  }
  if (!visionModule) throw lastErr || new Error('Failed to load tasks-vision module');

  const { FilesetResolver, HandLandmarker } = visionModule;

  // Resolve WASM files (try multiple CDNs)
  const WASM_ROOTS = [
    `https://unpkg.com/@mediapipe/tasks-vision@${TASKS_VISION_VERSION}/wasm`,
    `https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@${TASKS_VISION_VERSION}/wasm`
  ];
  let filesetResolver = null;
  lastErr = null;
  for (const root of WASM_ROOTS) {
    try {
      statusEl.textContent = `Loading hand model‚Ä¶ (wasm)`;
      filesetResolver = await withTimeout(
        FilesetResolver.forVisionTasks(root),
        15000,
        'Resolve tasks-vision WASM files'
      );
      break;
    } catch (err) {
      lastErr = err;
    }
  }
  if (!filesetResolver) throw lastErr || new Error('Failed to resolve WASM files');

  // Create detector
  statusEl.textContent = 'Loading hand model‚Ä¶ (graph)';
  handLandmarker = await withTimeout(
    HandLandmarker.createFromOptions(filesetResolver, {
      baseOptions: {
        // Use float16 model hosted by Google; fallback is handled by resolver/CDN
        modelAssetPath: 'https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task'
      },
      // Use string literal for runtime; VisionRunningMode is a TS type
      runningMode: 'VIDEO',
      numHands: 2,
      minHandDetectionConfidence: 0.6,
      minHandPresenceConfidence: 0.6,
      minTrackingConfidence: 0.6
    }),
    60000,
    'Create HandLandmarker'
  );

  statusEl.textContent = 'Model ready.';
}

// Wire UI
btnStart.addEventListener('click', async () => {
  btnStart.disabled = true;
  try {
    await enableCamera();
    await initHandLandmarker();
    running = true;
  } catch (err) {
    console.error(err);
    statusEl.innerHTML = `<span class="err">Start error:</span> ${err?.message || err}`;
    running = false;
    btnStart.disabled = false;
  }
});

btnReset.addEventListener('click', () => resetWidgets());
btnSpawn.addEventListener('click', () => {
  const kinds = ['square', 'circle', 'note'];
  const kind = kinds[Math.floor(Math.random() * kinds.length)];
  const x = overlay.width * (0.25 + Math.random() * 0.5);
  const y = overlay.height * (0.25 + Math.random() * 0.5);
  spawnWidget(kind, x, y);
});
btnClear.addEventListener('click', () => clearWidgets());

// 3D controls
if (btnAddCube) btnAddCube.addEventListener('click', () => spawn3D('cube'));
if (btnAddSphere) btnAddSphere.addEventListener('click', () => spawn3D('sphere'));
if (toggleRotate3D) toggleRotate3D.addEventListener('click', () => {
  rotate3DOnly = !rotate3DOnly;
  toggleRotate3D.dataset.on = String(rotate3DOnly);
  toggleRotate3D.setAttribute('aria-pressed', String(rotate3DOnly));
});

// Removed label/clock/sticker widget controls

togglePointer.addEventListener('click', () => {
  showPointer = !showPointer;
  togglePointer.dataset.on = String(showPointer);
  togglePointer.setAttribute('aria-pressed', String(showPointer));
});

btnDrawMode.addEventListener('click', () => {
  drawMode = !drawMode;
  btnDrawMode.dataset.on = String(drawMode);
  btnDrawMode.setAttribute('aria-pressed', String(drawMode));
  // Enable eraser only in draw mode
  btnEraser.disabled = !drawMode;
  if (!drawMode) {
    isDrawing = false;
    eraseMode = false;
    btnEraser.dataset.on = 'false';
    btnEraser.setAttribute('aria-pressed', 'false');
  }
});

btnEraser.addEventListener('click', () => {
  if (btnEraser.disabled) return;
  eraseMode = !eraseMode;
  btnEraser.dataset.on = String(eraseMode);
  btnEraser.setAttribute('aria-pressed', String(eraseMode));
});

colorPicker.addEventListener('input', (e) => {
  brushColor = e.target.value || brushColor;
});

brushSizeInput.addEventListener('input', (e) => {
  const v = Number(e.target.value);
  if (!Number.isNaN(v) && v > 0) brushSize = v;
});

// Pointer and smoothing controls
if (pointerSizeInput) {
  pointerSizeInput.addEventListener('input', (e) => {
    const v = Number(e.target.value);
    if (!Number.isNaN(v) && v > 0) pointerRadius = v;
  });
}
if (smoothingCutoffInput) {
  smoothingCutoffInput.addEventListener('input', (e) => {
    const v = Number(e.target.value);
    if (!Number.isNaN(v) && v > 0) {
      ONE_EURO_CFG.minCutoff = v;
      // Update all existing per-hand filters
      for (const h of hands) {
        if (!h.lmFilters) continue;
        for (const f of h.lmFilters) { f.fx.minCutoff = v; f.fy.minCutoff = v; }
      }
    }
  });
}
if (smoothingBetaInput) {
  smoothingBetaInput.addEventListener('input', (e) => {
    const v = Number(e.target.value);
    if (!Number.isNaN(v) && v >= 0) {
      ONE_EURO_CFG.beta = v;
      // Update all existing per-hand filters
      for (const h of hands) {
        if (!h.lmFilters) continue;
        for (const f of h.lmFilters) { f.fx.beta = v; f.fy.beta = v; }
      }
    }
  });
}

btnClearSketch.addEventListener('click', () => {
  const sctx = sketch.getContext('2d');
  sctx.clearRect(0, 0, sketch.width, sketch.height);
});

btnSave.addEventListener('click', () => {
  // Compose drawing + widgets into a single PNG (video is excluded)
  const out = document.createElement('canvas');
  out.width = overlay.width;
  out.height = overlay.height;
  const octx = out.getContext('2d');
  // Optional background fill
  octx.fillStyle = '#0b0e15';
  octx.fillRect(0, 0, out.width, out.height);
  // 3D layer (webgl) ‚Äî draw first
  try { octx.drawImage(webgl, 0, 0, out.width, out.height); } catch(e) {}
  // Drawing layer
  octx.drawImage(sketch, 0, 0);
  // Widgets
  drawWidgets(octx);
  const url = out.toDataURL('image/png');
  const a = document.createElement('a');
  a.href = url;
  a.download = 'hand-canvas.png';
  a.click();
});

// Toggle: allow/disallow second-hand resizing
if (toggleSecondHand) {
  toggleSecondHand.addEventListener('click', () => {
    allowSecondHand = !allowSecondHand;
    toggleSecondHand.dataset.on = String(allowSecondHand);
    toggleSecondHand.setAttribute('aria-pressed', String(allowSecondHand));
    // Immediately cancel any active resize if disabling
    if (!allowSecondHand) {
      resizeHand = null;
    }
  });
}

// Touch/mouse fallback (supports widgets drag or drawing)
let pointerDown = false;
stage.addEventListener('pointerdown', (e) => {
  const rect = overlay.getBoundingClientRect();
  const px = (e.clientX - rect.left) * devicePixelRatio;
  const py = (e.clientY - rect.top) * devicePixelRatio;
  if (drawMode) {
    isDrawing = true; pointerDown = true; lastDrawX = px; lastDrawY = py;
  } else {
    // Try 3D pick first on mouse/touch
    const threeHit = raycast3DFromPixels(px, py);
    if (threeHit) {
      beginThreeGrab(null, threeHit, { px, py });
      pointerDown = true;
    } else {
      const hit = pickWidget(px, py);
      if (hit != null) {
        grabbedId = hit;
        const w = widgets.find(v => v.id === hit);
        if (w) { grabOffsetX = w.x - px; grabOffsetY = w.y - py; w.vx = 0; w.vy = 0; }
        pointerDown = true;
      }
    }
  }
});
window.addEventListener('pointermove', (e) => {
  if (!pointerDown) return;
  const rect = overlay.getBoundingClientRect();
  const px = (e.clientX - rect.left) * devicePixelRatio;
  const py = (e.clientY - rect.top) * devicePixelRatio;
  if (drawMode && isDrawing) {
    const ctxS = sketch.getContext('2d');
    ctxS.save();
    ctxS.lineCap = 'round';
    ctxS.lineJoin = 'round';
    ctxS.lineWidth = brushSize * devicePixelRatio;
    if (eraseMode) {
      ctxS.globalCompositeOperation = 'destination-out';
      ctxS.strokeStyle = 'rgba(0,0,0,1)';
    } else {
      ctxS.globalCompositeOperation = 'source-over';
      ctxS.strokeStyle = brushColor;
    }
    ctxS.beginPath();
    ctxS.moveTo(lastDrawX, lastDrawY);
    ctxS.lineTo(px, py);
    ctxS.stroke();
    ctxS.restore();
    lastDrawX = px; lastDrawY = py;
  } else if (threeState.grabbed && !rotate3DOnly) {
    // Mouse/touch drag move for 3D when allowed
    updateThreeDragFromPixels(px, py);
  } else if (grabbedId != null) {
    moveWidget(grabbedId, px + grabOffsetX, py + grabOffsetY);
  }
});
window.addEventListener('pointerup', () => {
  if (drawMode) {
    isDrawing = false; pointerDown = false;
  } else {
    if (threeState.grabbed) endThreeGrab();
    const releasedId = grabbedId;
    pointerDown = false; grabbedId = null; grabOffsetX = 0; grabOffsetY = 0;
    const w = widgets.find(v => v.id === releasedId);
    if (w) { w.vx = 0; w.vy = 0; }
  }
});

// Double-click to edit text on note
stage.addEventListener('dblclick', (e) => {
  const rect = overlay.getBoundingClientRect();
  const px = (e.clientX - rect.left) * devicePixelRatio;
  const py = (e.clientY - rect.top) * devicePixelRatio;
  const id = pickWidget(px, py);
  if (id == null) return;
  const w = widgets.find(v => v.id === id);
  if (!w) return;
  if (w.kind === 'note') {
    const t = prompt('Edit text:', w.text || '');
    if (t != null) w.text = t;
  }
});

// Init sizing & default widgets
window.addEventListener('resize', () => { resizeCanvases(); });

// Load three.js, init 3D, then size canvases and start
await loadThree();
initThree();
resizeCanvases();
// Observe stage size changes to keep canvases perfectly fitted
new ResizeObserver(() => { resizeCanvases(); }).observe(stage);
resetWidgets();
statusEl.textContent = 'Ready. Click ‚ÄúEnable Camera‚Äù to start.';
// Start animation loop immediately so widgets render even before camera/model
requestAnimationFrame(frame);

</script>
</body>
</html>
